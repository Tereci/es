#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
unless File.respond_to? :realpath
  class File #:nodoc:
    def self.realpath path
      return realpath(File.readlink(path)) if symlink?(path)
      path
    end
  end
end
$: << File.expand_path(File.dirname(File.realpath(__FILE__)) + '/../lib')
require 'rubygems'
# require 'bundler/setup'
require 'gli'
require 'lib/es_version'
require 'gooddata'
require 'pp'
require 'logger'
require 'lib/es'
require 'ostruct'
require 'date'
require 'chronic'

include GLI

PID     = ENV['PID']
ES_NAME = ENV['ES_NAME']
LOGIN   = ENV['LOGIN']
PASS    = ENV['PASSWORD']

program_desc 'ES generator - Should help you with working with Event Store'

version Es::VERSION

# GoodData.logger = Logger.new(STDOUT)

desc 'Creates ES'
command :create do |c|
  c.action do |global_options,options,args|
    begin
      GoodData.post "/gdc/projects/#{PID}/eventStore/stores", {:store => {:storeId => ES_NAME}}
    rescue RestClient::BadRequest
      puts "Seems like eventstore with name #{ES_NAME} already exists"
      exit 1
    end
  end
end

desc 'Delete ES'
command :delete do |c|
  c.action do |global_options,options,args|
    GoodData.delete "/gdc/projects/#{PID}/eventStore/stores/#{ES_NAME}"
  end
end

desc 'Load data'
command :load do |c|
  c.desc 'Execute only for one entity.'
  c.default_value false
  c.flag [:o, :only]
  
  c.desc 'Print the task in the ugly oneliner mode for use in legacy tools.'
  c.default_value false
  c.switch [:j, :json]
  
  c.desc 'Verbose mode'
  c.default_value false
  c.switch [:v, :verbose]
  
  c.action do |global_options,options,args|

    filename = args.first
    fail "Provide path to the loading configuration as a first argument" if filename.nil?
    fail "File #{args.first} cannot be found" unless File.exist?(filename)

    load_config_file = Es::Helpers.load_config(filename)
    load = Es::Load.parse(load_config_file)

    load.entities.each do |entity|
      next if options[:only] && entity.name != options[:only]
      web_dav_file = Es::Helpers.load_destination_dir(PID, entity) + '/' + Es::Helpers.load_destination_file(entity)
      if options[:j]
        puts "Entity #{entity.name}".bright
        puts "load the file #{entity.file} to destination #{web_dav_file} and run the specified as the task"
        puts "======= Load JSON start"
        puts entity.to_load_fragment(PID).to_json.color(:blue)
        puts "======= Load JSON end"
        puts
      else
        if options[:verbose]
          puts "Entity #{entity.name}".bright
          puts "Will load from #{filename}"
        else
          
          # GoodData.connection.upload source, dir
          # data = GoodData.post "/gdc/projects/#{PID}/eventStore/stores/#{ES_NAME}/uploadTasks", task
          # link = data["asyncTask"]["link"]["poll"]
          # response = GoodData.get(link, :process => false)
          # while response.code != 204
          #   sleep 10
          #   response = GoodData.get(link, :process => false)
          # end
          # puts "Done #{source}"
          
        end
      end
    end
  end
end


desc 'Load Deleted Records'
command :load_deleted do |c|
  c.action do |global_options,options,args|

    fail "Provide path to the loading configuration as a first argument" if args.first.nil?
    fail "File #{args.fail} cannot be found" unless File.exist?(args.first)
    
    load_config_file = JSON.parse(File.read(args.first), :symbolize_names => true)
    # entities = Es::Helpers.parse_load_config(load_config_file)
    # entities.each do |f|
    # 
    #   source = f.file
    #   source_dir = File.dirname(source)
    #   filename = File.basename(source)
    #   base =  File.basename(source, '.*')
    #   ext = File.extname(source)
    #   deleted_filename = "#{base}-deleted#{ext}"
    #   deleted_source = "#{source_dir}/#{base}-deleted#{ext}"
    #   destination_dir = "#{f.name}-deleted-#{DateTime.now.strftime("%Y-%M-%d_%H:%M:%S")}"
    #   destination = "/uploads/#{destination_dir}/#{deleted_filename}"
    #   puts "Will load from #{deleted_source}"
    #   puts "Will load to #{destination}"
    #   GoodData.connection.upload deleted_source, destination_dir
    #   f.file = destination
    #   task = Es::generate('deleted_records', f)
    #   data = GoodData.post "/gdc/projects/#{PID}/eventStore/stores/#{ES_NAME}/uploadTasks", task
    #   link = data["asyncTask"]["link"]["poll"]
    #   response = GoodData.get(link, :process => false)
    #   while response.code != 204
    #     sleep 10
    #     response = GoodData.get(link, :process => false)
    #   end
    #   puts "Done #{source}"
    #   # puts task
    # end
  end
end

desc 'Extract'

command :extract do |c|
  
  c.desc 'Execute only for one entity.'
  c.default_value false
  c.flag [:o, :only]
  
  c.desc 'Verbose mode'
  c.default_value false
  c.switch [:v, :verbose]
  
  c.desc 'Print the task in the ugly oneliner mode for use in legacy tools.'
  c.default_value false
  c.switch [:j, :json]
  
  c.desc 'Run as usual but output the task definition in pretty print for debugging.'
  c.default_value true
  c.switch [:d, :debug]
  
  c.action do |global_options,options,args|
    
    fail "Provide path to the loading configuration as a first argument" if args.first.nil?
    load_config_file = args.first
    fail "Provide path to the extract configuration as a second argument" if args[1].nil?
    extract_config_file = args[1]
    
    load_config = Es::Helpers.load_config(load_config_file)
    load = Es::Load.parse(load_config)
    
    extract_config = Es::Helpers.load_config(extract_config_file)
    extract = Es::Extract.parse(extract_config, load)
    
    extract.entities.each do |entity|
      next if options[:only] && entity.name != options[:only]
      # pp extract.to_extract_fragment(PID)

      # web_dav_file = Es::Helpers.load_destination_dir(PID, entity) + '/' + Es::Helpers.load_destination_file(entity)
      if options[:verbose]
        puts "Entity #{entity.name.bright}"
        puts JSON.pretty_generate(entity.to_extract_fragment(PID)) if options[:verbose]
      end

      if options[:j]
        puts "Entity #{entity.name.bright}" if !options[:verbose]
        # puts "load the file #{entity.file} to destination #{web_dav_file} and run the specified as the task"
        puts "======= Extract JSON start"
        puts entity.to_extract_fragment(PID, :pretty => false).to_json.color(:blue)
        puts "======= Extract JSON end"
        puts
      else
        begin
          data = GoodData.post "/gdc/projects/#{PID}/eventStore/stores/#{ES_NAME}/readTasks", entity.to_extract_fragment(PID, :pretty => false).to_json
        rescue RestClient::BadRequest => e
          puts e.inspect
          exit 1
        end
        link = data["asyncTask"]["link"]["poll"]
        response = GoodData.get(link, :process => false)
        while response.code != 204
          sleep 10
          response = GoodData.get(link, :process => false)
        end
        web_dav_file = Es::Helpers.load_destination_dir(PID, entity) + '/' + Es::Helpers.load_destination_file(entity)
        GoodData.connection.download web_dav_file, entity.file
      end
    end
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  begin
    GoodData.connect LOGIN, PASS, nil, 0
  rescue RestClient::BadRequest => e
    puts "Login Failed"
    exit 1
  end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  pp exception.backtrace
  if exception.is_a?(SystemExit) && exception.status == 0
    false
  else
    true
  end
  
  # Error logic here
  # return false to skip default error handling
  # false
  # true
end

exit GLI.run(ARGV)
