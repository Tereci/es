#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
unless File.respond_to? :realpath
  class File #:nodoc:
    def self.realpath path
      return realpath(File.readlink(path)) if symlink?(path)
      path
    end
  end
end
$: << File.expand_path(File.dirname(File.realpath(__FILE__)) + '/../lib')
require 'rubygems'
# require 'bundler/setup'
require 'gli'
require 'es_version'
require 'gooddata'
require 'pp'
require 'logger'
require 'es'
require 'ostruct'
require 'date'
require 'chronic'
require 'fastercsv'

include GLI

PID       = ENV['PID']
ES_NAME   = ENV['ES_NAME']
LOGIN     = ENV['LOGIN']
PASSWORD  = ENV['PASSWORD']

program_desc 'ES generator - Should help you with working with Event Store'
version Es::VERSION

desc 'Turn on HTTP logger'
arg_name 'log'
switch [:l,:logger]

desc 'GD server'
arg_name 'server'
switch [:s,:server]

desc 'Creates ES'
command :create do |c|
  c.action do |global_options,options,args|
    begin
      GoodData.post "/gdc/projects/#{PID}/eventStore/stores", {:store => {:storeId => ES_NAME}}
    rescue RestClient::BadRequest
      puts "Seems like eventstore with name #{ES_NAME} already exists"
      exit 1
    end
  end
end

desc 'Delete ES'
command :delete do |c|
  c.action do |global_options,options,args|
    GoodData.delete "/gdc/projects/#{PID}/eventStore/stores/#{ES_NAME}"
  end
end


desc 'Show all types that are supported.'
command :types do |c|
  c.action do |global_options,options,args|
    Es::Field::FIELD_TYPES.each {|t| puts t}
  end
end

desc 'Load data'
command :load do |c|
  c.desc 'Execute only for one entity.'
  c.default_value false
  c.flag [:o, :only]
  
  c.desc 'Print the task in the ugly oneliner mode for use in legacy tools. Does not run the actual extract.'
  c.default_value false
  c.switch [:j, :json]
  
  c.desc 'Verbose mode'
  c.default_value false
  c.switch [:v, :verbose]
  
  c.action do |global_options,options,args|

    filename = args.first
    fail "Provide path to the loading configuration as a first argument" if filename.nil?
    fail "File #{args.first} cannot be found" unless File.exist?(filename)

    load_config_file = Es::Helpers.load_config(filename)
    load = Es::Load.parse(load_config_file)

    load.entities.each do |entity|
      next if options[:only] && entity.name != options[:only]
      web_dav_file = Es::Helpers.load_destination_dir(PID, entity) + '/' + Es::Helpers.destination_file(entity)
      if options[:verbose]
        puts "Entity #{entity.name}".bright
        puts "Configuration from #{filename}"
        puts "Will load from #{entity.file} to #{web_dav_file}"
        puts JSON::pretty_generate(entity.to_load_fragment(PID))
      end
      if options[:j]
        puts "Entity #{entity.name}".bright unless options[:verbose]
        puts "load the file #{entity.file} to destination #{web_dav_file} and run the specified as the task"
        puts "======= Load JSON start"
        puts entity.to_load_fragment(PID).to_json.color(:blue)
        puts "======= Load JSON end"
        puts
      else
        entity.load(PID)
        puts "Done" if options[:verbose]
      end
    end
  end
end


desc 'Load Deleted Records'
command :load_deleted do |c|
  c.action do |global_options,options,args|

    load_config_file = args.first
    fail "Provide path to the loading configuration as a first argument" if load_config_file.nil?
    fail "File #{args.fail} cannot be found" unless File.exist?(load_config_file)
    
    load_config = Es::Helpers.load_config(load_config_file)
    load = Es::Load.parse(load_config)
    
    load.entities.each do |entity|
      source_dir = File.dirname(entity.file)
      deleted_filename = Es::Helpers.destination_file(entity, :deleted => true)
      deleted_source = "#{source_dir}/#{deleted_filename}"
      next unless File.exist? deleted_source
      
      e = Es::Entity.new(entity.name, {
        :file   => deleted_source,
        :fields => [
          Es::Field.new('id', 'recordid'),
          Es::Field.new('timestamp', 'timestamp'),
          Es::Field.new('isDeleted', 'isDeleted')
        ]
      })
      GoodData.connection.upload deleted_filename, Es::Helpers.load_destination_dir(PID, entity)
      data = GoodData.post "/gdc/projects/#{PID}/eventStore/stores/#{ES_NAME}/uploadTasks", e.to_load_fragment(PID).to_json
      link = data["asyncTask"]["link"]["poll"]
      response = GoodData.get(link, :process => false)
      while response.code != 204
        sleep 10
        response = GoodData.get(link, :process => false)
      end
      puts "Done #{source}"
    end
  end
end

desc 'Extract'
command :extract do |c|
  
  c.desc 'Execute only for one entity.'
  c.default_value false
  c.flag [:o, :only]
  
  c.desc 'Verbose mode'
  c.default_value false
  c.switch [:v, :verbose]
  
  c.desc 'Print the task in the ugly oneliner mode for use in legacy tools. Does not run the actual extract.'
  c.default_value false
  c.switch [:j, :json]
  
  c.desc 'Run as usual but output the task definition in pretty print for debugging.'
  c.default_value true
  c.switch [:d, :debug]
  
  c.action do |global_options,options,args|
    
    fail "Provide path to the loading configuration as a first argument" if args.first.nil?
    load_config_file = args.first
    fail "Provide path to the extract configuration as a second argument" if args[1].nil?
    extract_config_file = args[1]
    
    load_config = Es::Helpers.load_config(load_config_file)
    load = Es::Load.parse(load_config)
    
    extract_config = Es::Helpers.load_config(extract_config_file)
    extract = Es::Extract.parse(extract_config, load)
    
    extract.entities.each do |entity|
      next if options[:only] && entity.name != options[:only]
      # pp extract.to_extract_fragment(PID)

      puts "Entity #{entity.name.bright}" if options[:verbose] || options[:json] || options[:debug]
      puts "Config from #{load_config_file} and #{extract_config_file}"

      puts JSON.pretty_generate(entity.to_extract_fragment(PID)) if options[:debug]

      if options[:json]
        # puts "load the file #{entity.file} to destination #{web_dav_file} and run the specified as the task"
        puts "======= Extract JSON start"
        puts entity.to_extract_fragment(PID, :pretty => false).to_json.color(:blue)
        puts "======= Extract JSON end"
        puts
      else
        begin
          data = GoodData.post "/gdc/projects/#{PID}/eventStore/stores/#{ES_NAME}/readTasks", entity.to_extract_fragment(PID, :pretty => false).to_json
        rescue RestClient::BadRequest => e
          puts e.inspect
          exit 1
        end
        link = data["asyncTask"]["link"]["poll"]
        response = GoodData.get(link, :process => false)
        while response.code != 204
          sleep 10
          response = GoodData.get(link, :process => false)
        end
        web_dav_file = Es::Helpers.extract_destination_dir(PID, entity) + '/' + Es::Helpers.destination_file(entity)
        GoodData.connection.download web_dav_file, entity.file
        puts "Done" if options[:verbose]
      end
    end
  end
end


desc 'Generate base conifg template'
command :generate_base do |c|
  
  c.desc 'Name of the entity.'
  c.default_value nil
  c.flag [:e, :entity]

  c.desc 'Input file.'
  c.default_value nil
  c.flag [:i, :input]

  c.desc 'Output filename. If not provided it print to STDOUT.'
  c.default_value nil
  c.flag [:o, :output]

  c.action do |global_options,options,args|
    entity_name = options[:entity]
    input_filename = options[:input]
    output_filename = options[:output]

    fail "You need to specify input entity name" if entity_name.nil?
    fail "You need to specify input file name" if input_filename.nil?

    headers = nil
    FasterCSV.foreach(input_filename, :headers => true, :return_headers => true) do |row|
      if row.header_row?
        headers = row.fields
        break
      end
    end

    load = Es::Load.new([
      Es::Entity.new(entity_name, {
        :file => input_filename,
        :fields => headers.map do |field_name|
          Es::Field.new(field_name, "none")
        end
      })
    ])

    config = JSON.pretty_generate(load.to_config)
    if output_filename.nil?
      puts config
    else
      File.open(output_filename, 'w') do |f|
        f.write config
      end
    end
  end
end

desc 'Truncate entity'
command :truncate do |c|
  
  c.desc 'Name of the entity.'
  c.default_value nil
  c.flag [:e, :entity]

  c.desc 'Timestamp in epoch.'
  c.default_value nil
  c.flag [:t, :timestamp]

  c.desc 'Base config filename.'
  c.default_value nil
  c.flag [:b, :base]

  c.action do |global_options,options,args|
    entity_name = options[:entity]
    timestamp = options[:timestamp]
    base_filename = options[:base]

    fail "You need to specify entity name" if entity_name.nil?
    fail "You need to specify timestamp" if timestamp.nil?
    fail "You need to specify base filename" if base_filename.nil?

    base_config_file = Es::Helpers.load_config(base_filename)
    base = Es::Load.parse(base_config_file)

    entity = base.get_entity(entity_name)
    fail "There is no entity named \"#{entity_name}\"" if entity.nil?

     begin
        data = GoodData.post "/gdc/projects/#{PID}/eventStore/stores/#{ES_NAME}/truncateTasks", {
          :truncateTask => {
            :entity     => entity_name,
            :timestamp  => timestamp.to_i
          }
        }
      rescue RestClient::BadRequest => e
        puts e.inspect
        exit 1
      end
      link = data["asyncTask"]["link"]["poll"]
      response = GoodData.get(link, :process => false)
      while response.code != 204
        sleep 10
        response = GoodData.get(link, :process => false)
      end
  end
end

desc 'Initial load column'
command :load_column do |c|
  
  c.desc 'Verbose mode'
  c.default_value false
  c.switch [:v, :verbose]
  
  c.desc 'Run as usual but output the task definition in pretty print for debugging.'
  c.default_value true
  c.switch [:d, :debug]

  c.desc 'Name of the column.'
  c.default_value nil
  c.flag [:n, :name]

  c.desc 'Name of the entity.'
  c.default_value nil
  c.flag [:e, :entity]

  c.desc 'Type of the column.'
  c.default_value nil
  c.flag [:t, :type]

  c.desc 'Base config filename.'
  c.default_value nil
  c.flag [:b, :base]

  c.desc 'Input data filename.'
  c.default_value nil
  c.flag [:i, :input]

  c.action do |global_options,options,args|
    puts "EXPERIMENTAL FEATURE - BEWARE".color(:red)
    file = options[:input]
    name = options[:name]
    type = options[:type]
    entity = options[:entity]
    base_filename = options[:base]

    fail "You need to specify column name" if name.nil?
    fail "You need to specify column type" if type.nil?
    fail "You need to specify entity name" if entity.nil?
    fail "You need to specify input file name" if file.nil?

    base_config_file = Es::Helpers.load_config(base_filename)
    base = Es::Load.parse(base_config_file)

    load = Es::Load.new([
      Es::Entity.new(entity, {
        :file => file,
        :fields => [
          Es::Field.new('id', 'recordid'),
          Es::Field.new('timestamp', 'timestamp'),
          Es::Field.new(name, type)
        ]
      })
    ])

    base.get_entity(entity).add_field(Es::Field.new(name, type))
    puts "Added field #{field.name}" if options[:verbose]
    base.to_config_file(base_filename)
    
    load.entities.first.load(PID)
  end
end

desc 'Shows more info about'
command :inspect do |c|

  c.action do |global_options,options,args|

    what = args.first
    filename = args[1]

    case what
    when "load"
      fail "Specify a file with base config" if filename.nil?
      base_config_file = Es::Helpers.load_config(filename)
      base = Es::Load.parse(base_config_file)
      base.entities.each do |entity|
        puts entity.to_table
      end
    end
  end
end


pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  fail "PID env variable should be specified" if PID.nil? || PID.empty?
  fail "ES_NAME env variable should be specified" if ES_NAME.nil? || ES_NAME.empty?
  fail "LOGIN env variable should be specified" if LOGIN.nil? || LOGIN.empty?
  fail "PASSWORD env variable should be specified" if PASSWORD.nil? || PASSWORD.empty?

  GoodData.logger = Logger.new(STDOUT) if global[:logger]
  GD_SERVER = global[:server]
  begin
    GoodData.connect LOGIN, PASSWORD, GD_SERVER, 0
  rescue RestClient::BadRequest => e
    puts "Login Failed"
    exit 1
  end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  pp exception.backtrace
  if exception.is_a?(SystemExit) && exception.status == 0
    false
  else
    true
  end
  
  # Error logic here
  # return false to skip default error handling
  # false
  # true
end

exit GLI.run(ARGV)
